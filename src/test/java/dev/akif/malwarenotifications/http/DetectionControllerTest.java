package dev.akif.malwarenotifications.http;

import dev.akif.malwarenotifications.TestData;
import dev.akif.malwarenotifications.detection.DetectionType;
import dev.akif.malwarenotifications.http.dto.DetectionDTO;
import dev.akif.malwarenotifications.http.dto.DeviceDTO;
import dev.akif.malwarenotifications.persistence.detection.DetectionCrudRepository;
import dev.akif.malwarenotifications.persistence.detection.DetectionEntity;
import dev.akif.malwarenotifications.persistence.device.DeviceCrudRepository;
import dev.akif.malwarenotifications.persistence.device.DeviceEntity;
import lombok.NonNull;
import lombok.val;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Isolated;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.util.NestedServletException;

import java.time.Instant;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import static dev.akif.malwarenotifications.TestUtils.assertPageHas;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@AutoConfigureMockMvc
@Isolated
@SpringBootTest
public class DetectionControllerTest {
    @Autowired
    private MockMvc mock;
    @Autowired
    private DeviceCrudRepository deviceRepository;
    @Autowired
    private DetectionCrudRepository detectionRepository;

    private final DeviceEntity iPhone = TestData.iPhoneEntity();
    private final DeviceEntity onePlus = TestData.onePlusEntity();
    private final DetectionEntity facebook = TestData.facebookEntity();
    private final DetectionEntity instagram = TestData.instagramEntity();
    private final DetectionEntity whatsApp = TestData.whatsAppEntity();

    private void deleteAllData() {
        detectionRepository.deleteAll();
        deviceRepository.deleteAll();
    }

    private void insertTestData() {
        deviceRepository.saveAll(List.of(iPhone, onePlus));
        detectionRepository.createOrUpdateAll(List.of(facebook, instagram, whatsApp));
    }

    @BeforeEach
    @Transactional
    void beforeEach() {
        deleteAllData();
        insertTestData();
    }

    @Test
    @DisplayName("Listing detections with invalid parameters")
    void testListDetectionsWithInvalidParameters() throws Exception {
        assertThrows(
                IllegalArgumentException.class,
                () -> {
                    throw assertThrows(
                            NestedServletException.class,
                            () -> mock.perform(get("/detections?page=0")).andReturn()
                    ).getCause();
                }
        );

        assertThrows(
                IllegalArgumentException.class,
                () -> {
                    throw assertThrows(
                            NestedServletException.class,
                            () -> mock.perform(get("/detections?perPage=0")).andReturn()
                    ).getCause();
                }
        );

        mock.perform(get("/detections?sortBy=UNKNOWN")).andExpect(status().isBadRequest());
        mock.perform(get("/detections?ascending=foo")).andExpect(status().isBadRequest());
        mock.perform(get("/detections?type=bar")).andExpect(status().isBadRequest());
    }

    @Test
    @DisplayName("Listing detections with default parameters")
    void testListDetectionsWithDefaultParameters() throws Exception {
        val result = mock.perform(get("/detections")).andExpect(status().isOk()).andReturn();

        assertEquals(
                buildPagedResponseJson(List.of(facebook, instagram, whatsApp), 1, 1),
                result.getResponse().getContentAsString()
        );
    }

    @Test
    @DisplayName("Listing detections with pagination")
    void testListDetectionsWithPagination() throws Exception {
        val result = mock.perform(get("/detections?page=2&perPage=2")).andExpect(status().isOk()).andReturn();

        assertEquals(
                buildPagedResponseJson(List.of(whatsApp), 2, 2),
                result.getResponse().getContentAsString()
        );
    }

    @Test
    @DisplayName("Listing detections with sorting")
    void testListDetectionsWithSorting() throws Exception {
        val result = mock.perform(get("/detections?perPage=1&sortBy=APP_TYPE&ascending=false")).andExpect(status().isOk()).andReturn();

        assertEquals(
                buildPagedResponseJson(List.of(facebook), 1, 3),
                result.getResponse().getContentAsString()
        );
    }

    @Test
    @DisplayName("Listing detections by type")
    void testListDetectionsByType() throws Exception {
        val result = mock.perform(get("/detections?type=RESOLVED")).andExpect(status().isOk()).andReturn();

        assertEquals(
                buildPagedResponseJson(List.of(whatsApp), 1, 1),
                result.getResponse().getContentAsString()
        );
    }

    @Test
    @DisplayName("Processing malware scan")
    void testProcessMalwareScan() throws Exception {
        assertPageHas(
                List.of(facebook, instagram, whatsApp),
                detectionRepository.findAll(TestData.defaultPage(), DetectionType.all())
        );

        val pirateBank = new DetectionDTO(UUID.randomUUID(), TestData.now, DetectionType.NEW, "PirateBank", "Banking");
        val newInstagram = new DetectionDTO(TestData.instagram.id(), TestData.now, DetectionType.NEW, "New Instagram", "Photography");

        val device = iPhone.toDevice();

        mock
                .perform(
                        post("/detections")
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(
                                        buildMalwareScanJson(
                                                new DeviceDTO(device),
                                                TestData.now,
                                                List.of(pirateBank, newInstagram)
                                        )
                                )
                )
                .andExpect(status().isOk());

        val resolvedFacebook = new DetectionEntity(TestData.facebook.id(), iPhone, TestData.now, DetectionType.RESOLVED, "Facebook", "Social");

        assertPageHas(
                List.of(
                        new DetectionEntity(pirateBank.toDetection(device)),
                        resolvedFacebook,
                        new DetectionEntity(newInstagram.toDetection(device)),
                        whatsApp
                ),
                detectionRepository.findAll(TestData.defaultPage(), DetectionType.all())
        );
    }

    private String buildPagedResponseJson(@NonNull List<DetectionEntity> detections, int page, int totalPages) {
        val data = detections
                .stream()
                .map(d ->
                        """
                                {"detection":{"id":"%s","time":"%s","type":"%s","appName":"%s","appType":"%s"},"device":{"id":"%s","type":"%s","model":"%s","os":"%s"}}""".formatted(
                                d.getId(),
                                d.getTime(),
                                d.getType(),
                                d.getAppName(),
                                d.getAppType(),
                                d.getDevice().getId(),
                                d.getDevice().getType(),
                                d.getDevice().getModel(),
                                d.getDevice().getOs()
                        )
                )
                .collect(Collectors.joining(",", "[", "]"));

        return """
                {"data":%s,"page":%d,"totalPages":%d}""".formatted(data, page, totalPages);
    }

    private String buildMalwareScanJson(@NonNull DeviceDTO device, @NonNull Instant time, @NonNull List<DetectionDTO> detections) {
        val deviceJson =
                """
                        {"id":"%s","type":"%s","model":"%s","os":"%s"}""".formatted(
                        device.id(),
                        device.type(),
                        device.model(),
                        device.os());

        val detectionsJson = detections
                .stream()
                .map(d -> switch (d.type()) {
                            case NEW -> """
                                    {"id":"%s","time":"%s","type":"%s","appName":"%s","appType":"%s"}""".formatted(
                                    d.id(),
                                    d.time(),
                                    d.type(),
                                    d.appName(),
                                    d.appType()
                            );

                            case RESOLVED -> """
                                    {"id":"%s","time":"%s","type":"%s"}""".formatted(
                                    d.id(),
                                    d.time(),
                                    d.type()
                            );
                        }
                )
                .collect(Collectors.joining(",", "[", "]"));

        return """
                {"device":%s,"time":"%s","detections":%s}""".formatted(deviceJson, time.toString(), detectionsJson);
    }
}
