package dev.akif.malwarenotifications.detection;

import dev.akif.malwarenotifications.device.Device;
import dev.akif.malwarenotifications.persistence.detection.DetectionEntity;
import dev.akif.malwarenotifications.persistence.detection.DetectionRepository;
import dev.akif.malwarenotifications.persistence.device.DeviceEntity;
import dev.akif.malwarenotifications.persistence.device.DeviceRepository;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@AllArgsConstructor
@Service
@Slf4j
public final class DetectionServiceImpl implements DetectionService {
    private final DeviceRepository deviceRepository;
    private final DetectionRepository detectionRepository;

    @Override
    public @NonNull List<Detection> listDetections() {
        return StreamSupport
                .stream(
                        detectionRepository
                                .findAll()
                                .spliterator(),
                        true
                )
                .map(DetectionEntity::toDetection)
                .collect(Collectors.toList());
    }

    @Override
    public void processMalwareScan(@NonNull Device device, @NonNull Instant time, @NonNull List<Detection> detections) {
        log.info("Creating/updating device {}", device);
        deviceRepository.save(new DeviceEntity(device));

        val existingDetectionsById = detectionRepository
                .findByDeviceId(device.id())
                .stream()
                .collect(Collectors.toMap(DetectionEntity::getId, Function.identity()));

        val detectionsInScanById = detections
                .stream()
                .collect(Collectors.toMap(Detection::id, d -> d));

        handleDetectionsToCreate(detectionsInScanById, existingDetectionsById);
        handleDetectionsToUpdate(detectionsInScanById, existingDetectionsById);
    }

    private void handleDetectionsToCreate(@NonNull Map<UUID, Detection> detectionsInScan,
                                          @NonNull Map<UUID, DetectionEntity> existingDetectionsById) {
        val detectionsToCreate = detectionsInScan
                .entrySet()
                .stream()
                .filter(e -> !existingDetectionsById.containsKey(e.getKey()))
                .map(e -> new DetectionEntity(e.getValue()))
                .toList();

        log.info("Creating {} new malware detections", detectionsToCreate.size());
        log.debug(
                "Malware detections to be created are {}",
                detectionsToCreate.stream().map(DetectionEntity::toString).collect(Collectors.joining(", ", "[", "]"))
        );

        detectionRepository.saveAll(detectionsToCreate);
    }

    private void handleDetectionsToUpdate(@NonNull Map<UUID, Detection> detectionsInScan,
                                          @NonNull Map<UUID, DetectionEntity> existingDetectionsById) {
        val detectionsToUpdate = detectionsInScan
                .entrySet()
                .stream()
                .filter(e -> existingDetectionsById.containsKey(e.getKey()))
                .map(e -> new DetectionEntity(e.getValue()))
                .toList();

        log.info("Updating {} malware detections", detectionsToUpdate.size());
        log.debug(
                "Malware detections to be updated are {}",
                detectionsToUpdate.stream().map(DetectionEntity::toString).collect(Collectors.joining(", ", "[", "]"))
        );

        detectionRepository.saveAll(detectionsToUpdate);
    }
}
