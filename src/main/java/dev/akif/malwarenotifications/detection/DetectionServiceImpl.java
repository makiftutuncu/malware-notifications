package dev.akif.malwarenotifications.detection;

import dev.akif.malwarenotifications.device.Device;
import dev.akif.malwarenotifications.persistence.detection.DetectionEntity;
import dev.akif.malwarenotifications.persistence.detection.DetectionRepository;
import dev.akif.malwarenotifications.persistence.device.DeviceEntity;
import dev.akif.malwarenotifications.persistence.device.DeviceRepository;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@AllArgsConstructor
@Service
@Slf4j
public final class DetectionServiceImpl implements DetectionService {
    private final DeviceRepository deviceRepository;
    private final DetectionRepository detectionRepository;

    public static DetectionEntity processDetection(DetectionEntity existingDetectionEntity, Detection detectionInScan, @NonNull Instant scanTime) {
        DetectionEntity detectionToReturn = null;

        if (existingDetectionEntity == null) {
            if (detectionInScan != null) {
                detectionToReturn = new DetectionEntity(detectionInScan);
                log.debug("Found a new detection {}", detectionToReturn);
            }
        } else {
            detectionToReturn = existingDetectionEntity;

            if (detectionInScan != null) {
                existingDetectionEntity.setTime(detectionInScan.time());
                existingDetectionEntity.setType(detectionInScan.type());

                // Update app details only if not being resolved because resolved detections don't have app details
                // so we'd end up overwriting them with nulls
                if (detectionInScan.type() != DetectionType.RESOLVED) {
                    existingDetectionEntity.setAppName(detectionInScan.appName());
                    existingDetectionEntity.setAppType(detectionInScan.appType());
                }

                log.debug("Updating detection as {}", detectionToReturn);
            } else {
                existingDetectionEntity.setTime(scanTime);
                existingDetectionEntity.setType(DetectionType.RESOLVED);

                log.debug("Resolving detection as {}", detectionToReturn);
            }
        }

        return detectionToReturn;
    }

    @Override
    public @NonNull Page<Detection> listDetections(@NonNull Pageable pageable, @NonNull Set<DetectionType> detectionTypes) {
        return detectionRepository
                .findAll(pageable, detectionTypes)
                .map(DetectionEntity::toDetection);
    }

    @Override
    public void processMalwareScan(@NonNull Device device, @NonNull Instant scanTime, @NonNull List<Detection> detections) {
        log.info("Creating/updating device {}", device);
        deviceRepository.createOrUpdate(new DeviceEntity(device));

        val detectionsInScanById = detections
                .stream()
                .collect(Collectors.toMap(Detection::id, d -> d));

        val existingDetectionsById = detectionRepository
                .findByDeviceId(device.id())
                .stream()
                .collect(Collectors.toMap(DetectionEntity::getId, Function.identity()));

        val allIds = new HashSet<UUID>();
        allIds.addAll(detectionsInScanById.keySet());
        allIds.addAll(existingDetectionsById.keySet());

        val allDetectionsToProcess = allIds
                .stream()
                .flatMap(id -> {
                    val existingDetectionEntity = existingDetectionsById.get(id);
                    val detectionInScan = detectionsInScanById.get(id);
                    val detectionEntity = DetectionServiceImpl.processDetection(existingDetectionEntity, detectionInScan, scanTime);
                    return detectionEntity != null ? Stream.of(detectionEntity) : Stream.empty();
                })
                .collect(Collectors.toList());

        log.info("Creating/updating {} detections for device {}", allDetectionsToProcess.size(), device);

        detectionRepository.createOrUpdateAll(allDetectionsToProcess);
    }
}
